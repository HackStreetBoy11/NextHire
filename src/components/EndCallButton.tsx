import { useCall, useCallStateHooks } from "@stream-io/video-react-sdk";
/*
    From Stream Video SDK (a library that powers real-time video calls)
    useCall() -> gives you the current call object(with all call method like endCall(),id,state,etc)
    usecallStateHooks()->gives you access to state hooks like useLocalParicipant() to get info about participant(yourself,remove users,etc)
*/
import { useMutation, useQuery } from "convex/react";
import { useRouter } from "next/navigation";
/*
    after ending the call it redirects the user to /
*/
import { api } from "../../convex/_generated/api";
/*
    imports all your convex api endpoints (autogenerated)
    you're using this to call functions like:
        - api.interviews.getInterviewByStreamCallId
        - api.interviews.updateInterviewStatus
*/
import { Button } from "./ui/button";
/*
    button from shadcn/ui
*/
import toast from "react-hot-toast";
function EndCallButton() {
    const call = useCall();
    /*
        fetches the current video call object from stream sdk
        this object includes
            - id-> call ID
            - endCall() -> function to end the call
            - state.createBy -> the user who started the call
    */

    const router = useRouter();
    //  used later to redirect hte user after ending the call
    const { useLocalParticipant } = useCallStateHooks();
    const localParticipant = useLocalParticipant();
    /*
    extracts a hook useLocalParticipant from stream's state hooks.
    then call it to get info about the current logged-in participant(yourself)
    this includes details like
        -userId
        -name
        -isSpeaking
    */


    const updateInterviewStatus = useMutation(api.interviews.updateInterviewStatus);
    // creates a convex mutation function for updating interview status
    //  you'll later call it to mark the interview as "completed"
    const interview = useQuery(api.interviews.getInterviewByStreamCallId, {
        streamCallId: call?.id || "",
    });
    // calls a convex query to get the current interview document (record ) from your database by using the current stream call's ID
    // if call doesn't exist yet, fallback to an empty string

    if (!call || !interview) return null;
    // Prevents rendering anything until both the call and interview are fetched
    // avoids runtime errors like trying to access call.id or interview._id before they exist

    const isMeetingOwner = localParticipant?.userId === call.state.createdBy?.id;
    if (!isMeetingOwner) return null;
    // Checks if the current participant (you) is the creator of the call.
    // Only the creator/interviewer is allowed to end the meeting.
    // If not the owner â†’ return null (hide the button).

    const endCall = async () => {
        try {
            await call.endCall();
            // Uses Stream SDK to end the call for everyone (all participants disconnected)
            await updateInterviewStatus({
                id: interview._id,
                status: "completed",
            });
            // Calls Convex mutation to mark the interview as "completed" in your database.
            // Helps keep UI and DB in sync.

            router.push("/");
            // Redirects interviewer to home page (or dashboard)
            toast.success("Meeting ended for everyone");
        } catch (error) {
            console.log(error);
            toast.error("Failed to end meeting");
        }
    };

    return (
        <Button variant={"destructive"} onClick={endCall}>
            End Meeting
        </Button>
    );
    /*
        Displays a red("destructive")button labeled end meeting
        when clicked -> triggers the endcalls() function
        Hidden for non-owners or missing call
    */
}
export default EndCallButton;